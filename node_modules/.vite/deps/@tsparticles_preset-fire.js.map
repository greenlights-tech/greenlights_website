{
  "version": 3,
  "sources": ["../../@tsparticles/move-base/browser/Utils.js", "../../@tsparticles/move-base/browser/BaseMover.js", "../../@tsparticles/move-base/browser/index.js", "../../@tsparticles/shape-circle/browser/Utils.js", "../../@tsparticles/shape-circle/browser/CircleDrawer.js", "../../@tsparticles/shape-circle/browser/index.js", "../../@tsparticles/updater-color/browser/ColorUpdater.js", "../../@tsparticles/updater-color/browser/index.js", "../../@tsparticles/plugin-hex-color/browser/HexColorManager.js", "../../@tsparticles/plugin-hex-color/browser/index.js", "../../@tsparticles/plugin-hsl-color/browser/HslColorManager.js", "../../@tsparticles/plugin-hsl-color/browser/index.js", "../../@tsparticles/updater-opacity/browser/OpacityUpdater.js", "../../@tsparticles/updater-opacity/browser/index.js", "../../@tsparticles/updater-out-modes/browser/Utils.js", "../../@tsparticles/updater-out-modes/browser/BounceOutMode.js", "../../@tsparticles/updater-out-modes/browser/DestroyOutMode.js", "../../@tsparticles/updater-out-modes/browser/NoneOutMode.js", "../../@tsparticles/updater-out-modes/browser/OutOutMode.js", "../../@tsparticles/updater-out-modes/browser/OutOfCanvasUpdater.js", "../../@tsparticles/updater-out-modes/browser/index.js", "../../@tsparticles/plugin-rgb-color/browser/RgbColorManager.js", "../../@tsparticles/plugin-rgb-color/browser/index.js", "../../@tsparticles/updater-size/browser/SizeUpdater.js", "../../@tsparticles/updater-size/browser/index.js", "../../@tsparticles/basic/browser/index.js", "../../@tsparticles/interaction-external-push/browser/Options/Classes/Push.js", "../../@tsparticles/interaction-external-push/browser/Pusher.js", "../../@tsparticles/interaction-external-push/browser/index.js", "../../@tsparticles/preset-fire/esm/options.js", "../../@tsparticles/preset-fire/esm/index.js"],
  "sourcesContent": ["import { RotateDirection, clamp, getDistance, getDistances, getRandom, getRangeValue, } from \"@tsparticles/engine\";\r\nconst half = 0.5, double = 2, minVelocity = 0, identity = 1, moveSpeedFactor = 60, minSpinRadius = 0, spinFactor = 0.01, doublePI = Math.PI * double;\r\nexport function applyDistance(particle) {\r\n    const initialPosition = particle.initialPosition, { dx, dy } = getDistances(initialPosition, particle.position), dxFixed = Math.abs(dx), dyFixed = Math.abs(dy), { maxDistance } = particle.retina, hDistance = maxDistance.horizontal, vDistance = maxDistance.vertical;\r\n    if (!hDistance && !vDistance) {\r\n        return;\r\n    }\r\n    const hasHDistance = (hDistance && dxFixed >= hDistance) ?? false, hasVDistance = (vDistance && dyFixed >= vDistance) ?? false;\r\n    if ((hasHDistance || hasVDistance) && !particle.misplaced) {\r\n        particle.misplaced = (!!hDistance && dxFixed > hDistance) || (!!vDistance && dyFixed > vDistance);\r\n        if (hDistance) {\r\n            particle.velocity.x = particle.velocity.y * half - particle.velocity.x;\r\n        }\r\n        if (vDistance) {\r\n            particle.velocity.y = particle.velocity.x * half - particle.velocity.y;\r\n        }\r\n    }\r\n    else if ((!hDistance || dxFixed < hDistance) && (!vDistance || dyFixed < vDistance) && particle.misplaced) {\r\n        particle.misplaced = false;\r\n    }\r\n    else if (particle.misplaced) {\r\n        const pos = particle.position, vel = particle.velocity;\r\n        if (hDistance &&\r\n            ((pos.x < initialPosition.x && vel.x < minVelocity) || (pos.x > initialPosition.x && vel.x > minVelocity))) {\r\n            vel.x *= -getRandom();\r\n        }\r\n        if (vDistance &&\r\n            ((pos.y < initialPosition.y && vel.y < minVelocity) || (pos.y > initialPosition.y && vel.y > minVelocity))) {\r\n            vel.y *= -getRandom();\r\n        }\r\n    }\r\n}\r\nexport function move(particle, moveOptions, moveSpeed, maxSpeed, moveDrift, reduceFactor, delta) {\r\n    applyPath(particle, delta);\r\n    const gravityOptions = particle.gravity, gravityFactor = gravityOptions?.enable && gravityOptions.inverse ? -identity : identity;\r\n    if (moveDrift && moveSpeed) {\r\n        particle.velocity.x += (moveDrift * delta.factor) / (moveSpeedFactor * moveSpeed);\r\n    }\r\n    if (gravityOptions?.enable && moveSpeed) {\r\n        particle.velocity.y +=\r\n            (gravityFactor * (gravityOptions.acceleration * delta.factor)) / (moveSpeedFactor * moveSpeed);\r\n    }\r\n    const decay = particle.moveDecay;\r\n    particle.velocity.multTo(decay);\r\n    const velocity = particle.velocity.mult(moveSpeed);\r\n    if (gravityOptions?.enable &&\r\n        maxSpeed > minVelocity &&\r\n        ((!gravityOptions.inverse && velocity.y >= minVelocity && velocity.y >= maxSpeed) ||\r\n            (gravityOptions.inverse && velocity.y <= minVelocity && velocity.y <= -maxSpeed))) {\r\n        velocity.y = gravityFactor * maxSpeed;\r\n        if (moveSpeed) {\r\n            particle.velocity.y = velocity.y / moveSpeed;\r\n        }\r\n    }\r\n    const zIndexOptions = particle.options.zIndex, zVelocityFactor = (identity - particle.zIndexFactor) ** zIndexOptions.velocityRate;\r\n    velocity.multTo(zVelocityFactor);\r\n    velocity.multTo(reduceFactor);\r\n    const { position } = particle;\r\n    position.addTo(velocity);\r\n    if (moveOptions.vibrate) {\r\n        position.x += Math.sin(position.x * Math.cos(position.y)) * reduceFactor;\r\n        position.y += Math.cos(position.y * Math.sin(position.x)) * reduceFactor;\r\n    }\r\n}\r\nexport function spin(particle, moveSpeed, reduceFactor) {\r\n    const container = particle.container;\r\n    if (!particle.spin) {\r\n        return;\r\n    }\r\n    const spinClockwise = particle.spin.direction === RotateDirection.clockwise, updateFunc = {\r\n        x: spinClockwise ? Math.cos : Math.sin,\r\n        y: spinClockwise ? Math.sin : Math.cos,\r\n    };\r\n    particle.position.x =\r\n        particle.spin.center.x + particle.spin.radius * updateFunc.x(particle.spin.angle) * reduceFactor;\r\n    particle.position.y =\r\n        particle.spin.center.y + particle.spin.radius * updateFunc.y(particle.spin.angle) * reduceFactor;\r\n    particle.spin.radius += particle.spin.acceleration * reduceFactor;\r\n    const maxCanvasSize = Math.max(container.canvas.size.width, container.canvas.size.height), halfMaxSize = maxCanvasSize * half;\r\n    if (particle.spin.radius > halfMaxSize) {\r\n        particle.spin.radius = halfMaxSize;\r\n        particle.spin.acceleration *= -identity;\r\n    }\r\n    else if (particle.spin.radius < minSpinRadius) {\r\n        particle.spin.radius = minSpinRadius;\r\n        particle.spin.acceleration *= -identity;\r\n    }\r\n    particle.spin.angle += moveSpeed * spinFactor * (identity - particle.spin.radius / maxCanvasSize);\r\n}\r\nexport function applyPath(particle, delta) {\r\n    const particlesOptions = particle.options, pathOptions = particlesOptions.move.path, pathEnabled = pathOptions.enable;\r\n    if (!pathEnabled) {\r\n        return;\r\n    }\r\n    if (particle.lastPathTime <= particle.pathDelay) {\r\n        particle.lastPathTime += delta.value;\r\n        return;\r\n    }\r\n    const path = particle.pathGenerator?.generate(particle, delta);\r\n    if (path) {\r\n        particle.velocity.addTo(path);\r\n    }\r\n    if (pathOptions.clamp) {\r\n        particle.velocity.x = clamp(particle.velocity.x, -identity, identity);\r\n        particle.velocity.y = clamp(particle.velocity.y, -identity, identity);\r\n    }\r\n    particle.lastPathTime -= particle.pathDelay;\r\n}\r\nexport function getProximitySpeedFactor(particle) {\r\n    return particle.slow.inRange ? particle.slow.factor : identity;\r\n}\r\nexport function initSpin(particle) {\r\n    const container = particle.container, options = particle.options, spinOptions = options.move.spin;\r\n    if (!spinOptions.enable) {\r\n        return;\r\n    }\r\n    const spinPos = spinOptions.position ?? { x: 50, y: 50 }, spinFactor = 0.01, spinCenter = {\r\n        x: spinPos.x * spinFactor * container.canvas.size.width,\r\n        y: spinPos.y * spinFactor * container.canvas.size.height,\r\n    }, pos = particle.getPosition(), distance = getDistance(pos, spinCenter), spinAcceleration = getRangeValue(spinOptions.acceleration);\r\n    particle.retina.spinAcceleration = spinAcceleration * container.retina.pixelRatio;\r\n    particle.spin = {\r\n        center: spinCenter,\r\n        direction: particle.velocity.x >= minVelocity ? RotateDirection.clockwise : RotateDirection.counterClockwise,\r\n        angle: getRandom() * doublePI,\r\n        radius: distance,\r\n        acceleration: particle.retina.spinAcceleration,\r\n    };\r\n}\r\n", "import { getRangeMax, getRangeValue } from \"@tsparticles/engine\";\r\nimport { applyDistance, getProximitySpeedFactor, initSpin, move, spin } from \"./Utils.js\";\r\nconst diffFactor = 2, defaultSizeFactor = 1, defaultDeltaFactor = 1;\r\nexport class BaseMover {\r\n    init(particle) {\r\n        const options = particle.options, gravityOptions = options.move.gravity;\r\n        particle.gravity = {\r\n            enable: gravityOptions.enable,\r\n            acceleration: getRangeValue(gravityOptions.acceleration),\r\n            inverse: gravityOptions.inverse,\r\n        };\r\n        initSpin(particle);\r\n    }\r\n    isEnabled(particle) {\r\n        return !particle.destroyed && particle.options.move.enable;\r\n    }\r\n    move(particle, delta) {\r\n        const particleOptions = particle.options, moveOptions = particleOptions.move;\r\n        if (!moveOptions.enable) {\r\n            return;\r\n        }\r\n        const container = particle.container, pxRatio = container.retina.pixelRatio;\r\n        particle.retina.moveSpeed ??= getRangeValue(moveOptions.speed) * pxRatio;\r\n        particle.retina.moveDrift ??= getRangeValue(particle.options.move.drift) * pxRatio;\r\n        const slowFactor = getProximitySpeedFactor(particle), reduceFactor = container.retina.reduceFactor, baseSpeed = particle.retina.moveSpeed, moveDrift = particle.retina.moveDrift, maxSize = getRangeMax(particleOptions.size.value) * pxRatio, sizeFactor = moveOptions.size ? particle.getRadius() / maxSize : defaultSizeFactor, deltaFactor = delta.factor || defaultDeltaFactor, moveSpeed = (baseSpeed * sizeFactor * slowFactor * deltaFactor) / diffFactor, maxSpeed = particle.retina.maxSpeed ?? container.retina.maxSpeed;\r\n        if (moveOptions.spin.enable) {\r\n            spin(particle, moveSpeed, reduceFactor);\r\n        }\r\n        else {\r\n            move(particle, moveOptions, moveSpeed, maxSpeed, moveDrift, reduceFactor, delta);\r\n        }\r\n        applyDistance(particle);\r\n    }\r\n}\r\n", "import { BaseMover } from \"./BaseMover.js\";\r\nexport async function loadBaseMover(engine, refresh = true) {\r\n    engine.checkVersion(\"3.9.1\");\r\n    await engine.addMover(\"base\", () => {\r\n        return Promise.resolve(new BaseMover());\r\n    }, refresh);\r\n}\r\n", "const double = 2, doublePI = Math.PI * double, minAngle = 0, origin = { x: 0, y: 0 };\r\nexport function drawCircle(data) {\r\n    const { context, particle, radius } = data;\r\n    if (!particle.circleRange) {\r\n        particle.circleRange = { min: minAngle, max: doublePI };\r\n    }\r\n    const circleRange = particle.circleRange;\r\n    context.arc(origin.x, origin.y, radius, circleRange.min, circleRange.max, false);\r\n}\r\n", "import { degToRad, isObject } from \"@tsparticles/engine\";\r\nimport { drawCircle } from \"./Utils.js\";\r\nconst sides = 12, maxAngle = 360, minAngle = 0;\r\nexport class CircleDrawer {\r\n    constructor() {\r\n        this.validTypes = [\"circle\"];\r\n    }\r\n    draw(data) {\r\n        drawCircle(data);\r\n    }\r\n    getSidesCount() {\r\n        return sides;\r\n    }\r\n    particleInit(container, particle) {\r\n        const shapeData = particle.shapeData, angle = shapeData?.angle ?? {\r\n            max: maxAngle,\r\n            min: minAngle,\r\n        };\r\n        particle.circleRange = !isObject(angle)\r\n            ? {\r\n                min: minAngle,\r\n                max: degToRad(angle),\r\n            }\r\n            : { min: degToRad(angle.min), max: degToRad(angle.max) };\r\n    }\r\n}\r\n", "import { CircleDrawer } from \"./CircleDrawer.js\";\r\nexport async function loadCircleShape(engine, refresh = true) {\r\n    engine.checkVersion(\"3.9.1\");\r\n    await engine.addShape(new CircleDrawer(), refresh);\r\n}\r\n", "import { getHslAnimationFromHsl, rangeColorToHsl, updateColor, } from \"@tsparticles/engine\";\r\nexport class ColorUpdater {\r\n    constructor(container, engine) {\r\n        this._container = container;\r\n        this._engine = engine;\r\n    }\r\n    init(particle) {\r\n        const hslColor = rangeColorToHsl(this._engine, particle.options.color, particle.id, particle.options.reduceDuplicates);\r\n        if (hslColor) {\r\n            particle.color = getHslAnimationFromHsl(hslColor, particle.options.color.animation, this._container.retina.reduceFactor);\r\n        }\r\n    }\r\n    isEnabled(particle) {\r\n        const { h: hAnimation, s: sAnimation, l: lAnimation } = particle.options.color.animation, { color } = particle;\r\n        return (!particle.destroyed &&\r\n            !particle.spawning &&\r\n            ((color?.h.value !== undefined && hAnimation.enable) ||\r\n                (color?.s.value !== undefined && sAnimation.enable) ||\r\n                (color?.l.value !== undefined && lAnimation.enable)));\r\n    }\r\n    update(particle, delta) {\r\n        updateColor(particle.color, delta);\r\n    }\r\n}\r\n", "import { ColorUpdater } from \"./ColorUpdater.js\";\r\nexport async function loadColorUpdater(engine, refresh = true) {\r\n    engine.checkVersion(\"3.9.1\");\r\n    await engine.addParticleUpdater(\"color\", container => {\r\n        return Promise.resolve(new ColorUpdater(container, engine));\r\n    }, refresh);\r\n}\r\n", "var RgbIndexes;\r\n(function (RgbIndexes) {\r\n    RgbIndexes[RgbIndexes[\"r\"] = 1] = \"r\";\r\n    RgbIndexes[RgbIndexes[\"g\"] = 2] = \"g\";\r\n    RgbIndexes[RgbIndexes[\"b\"] = 3] = \"b\";\r\n    RgbIndexes[RgbIndexes[\"a\"] = 4] = \"a\";\r\n})(RgbIndexes || (RgbIndexes = {}));\r\nconst shorthandHexRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])([a-f\\d])?$/i, hexRegex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})?$/i, hexRadix = 16, defaultAlpha = 1, alphaFactor = 0xff;\r\nexport class HexColorManager {\r\n    constructor() {\r\n        this.key = \"hex\";\r\n        this.stringPrefix = \"#\";\r\n    }\r\n    handleColor(color) {\r\n        return this._parseString(color.value);\r\n    }\r\n    handleRangeColor(color) {\r\n        return this._parseString(color.value);\r\n    }\r\n    parseString(input) {\r\n        return this._parseString(input);\r\n    }\r\n    _parseString(hexColor) {\r\n        if (typeof hexColor !== \"string\") {\r\n            return;\r\n        }\r\n        if (!hexColor?.startsWith(this.stringPrefix)) {\r\n            return;\r\n        }\r\n        const hexFixed = hexColor.replace(shorthandHexRegex, (_, r, g, b, a) => {\r\n            return r + r + g + g + b + b + (a !== undefined ? a + a : \"\");\r\n        }), result = hexRegex.exec(hexFixed);\r\n        return result\r\n            ? {\r\n                a: result[RgbIndexes.a] !== undefined\r\n                    ? parseInt(result[RgbIndexes.a], hexRadix) / alphaFactor\r\n                    : defaultAlpha,\r\n                b: parseInt(result[RgbIndexes.b], hexRadix),\r\n                g: parseInt(result[RgbIndexes.g], hexRadix),\r\n                r: parseInt(result[RgbIndexes.r], hexRadix),\r\n            }\r\n            : undefined;\r\n    }\r\n}\r\n", "import { HexColorManager } from \"./HexColorManager.js\";\r\nexport async function loadHexColorPlugin(engine, refresh = true) {\r\n    engine.checkVersion(\"3.9.1\");\r\n    await engine.addColorManager(new HexColorManager(), refresh);\r\n}\r\n", "import { getRangeValue, hslToRgb, hslaToRgba, parseAlpha, } from \"@tsparticles/engine\";\r\nvar HslIndexes;\r\n(function (HslIndexes) {\r\n    HslIndexes[HslIndexes[\"h\"] = 1] = \"h\";\r\n    HslIndexes[HslIndexes[\"s\"] = 2] = \"s\";\r\n    HslIndexes[HslIndexes[\"l\"] = 3] = \"l\";\r\n    HslIndexes[HslIndexes[\"a\"] = 5] = \"a\";\r\n})(HslIndexes || (HslIndexes = {}));\r\nexport class HslColorManager {\r\n    constructor() {\r\n        this.key = \"hsl\";\r\n        this.stringPrefix = \"hsl\";\r\n    }\r\n    handleColor(color) {\r\n        const colorValue = color.value, hslColor = colorValue.hsl ?? color.value;\r\n        if (hslColor.h !== undefined && hslColor.s !== undefined && hslColor.l !== undefined) {\r\n            return hslToRgb(hslColor);\r\n        }\r\n    }\r\n    handleRangeColor(color) {\r\n        const colorValue = color.value, hslColor = colorValue.hsl ?? color.value;\r\n        if (hslColor.h !== undefined && hslColor.l !== undefined) {\r\n            return hslToRgb({\r\n                h: getRangeValue(hslColor.h),\r\n                l: getRangeValue(hslColor.l),\r\n                s: getRangeValue(hslColor.s),\r\n            });\r\n        }\r\n    }\r\n    parseString(input) {\r\n        if (!input.startsWith(\"hsl\")) {\r\n            return;\r\n        }\r\n        const regex = /hsla?\\(\\s*(\\d+)\\s*[\\s,]\\s*(\\d+)%\\s*[\\s,]\\s*(\\d+)%\\s*([\\s,]\\s*(0|1|0?\\.\\d+|(\\d{1,3})%)\\s*)?\\)/i, result = regex.exec(input), minLength = 4, defaultAlpha = 1, radix = 10;\r\n        return result\r\n            ? hslaToRgba({\r\n                a: result.length > minLength ? parseAlpha(result[HslIndexes.a]) : defaultAlpha,\r\n                h: parseInt(result[HslIndexes.h], radix),\r\n                l: parseInt(result[HslIndexes.l], radix),\r\n                s: parseInt(result[HslIndexes.s], radix),\r\n            })\r\n            : undefined;\r\n    }\r\n}\r\n", "import { HslColorManager } from \"./HslColorManager.js\";\r\nexport async function loadHslColorPlugin(engine, refresh = true) {\r\n    engine.checkVersion(\"3.9.1\");\r\n    await engine.addColorManager(new HslColorManager(), refresh);\r\n}\r\n", "import { getRandom, getRangeValue, initParticleNumericAnimationValue, percentDenominator, updateAnimation, } from \"@tsparticles/engine\";\r\nexport class OpacityUpdater {\r\n    constructor(container) {\r\n        this.container = container;\r\n    }\r\n    init(particle) {\r\n        const opacityOptions = particle.options.opacity, pxRatio = 1;\r\n        particle.opacity = initParticleNumericAnimationValue(opacityOptions, pxRatio);\r\n        const opacityAnimation = opacityOptions.animation;\r\n        if (opacityAnimation.enable) {\r\n            particle.opacity.velocity =\r\n                (getRangeValue(opacityAnimation.speed) / percentDenominator) * this.container.retina.reduceFactor;\r\n            if (!opacityAnimation.sync) {\r\n                particle.opacity.velocity *= getRandom();\r\n            }\r\n        }\r\n    }\r\n    isEnabled(particle) {\r\n        const none = 0;\r\n        return (!particle.destroyed &&\r\n            !particle.spawning &&\r\n            !!particle.opacity &&\r\n            particle.opacity.enable &&\r\n            ((particle.opacity.maxLoops ?? none) <= none ||\r\n                ((particle.opacity.maxLoops ?? none) > none &&\r\n                    (particle.opacity.loops ?? none) < (particle.opacity.maxLoops ?? none))));\r\n    }\r\n    reset(particle) {\r\n        if (particle.opacity) {\r\n            particle.opacity.time = 0;\r\n            particle.opacity.loops = 0;\r\n        }\r\n    }\r\n    update(particle, delta) {\r\n        if (!this.isEnabled(particle) || !particle.opacity) {\r\n            return;\r\n        }\r\n        updateAnimation(particle, particle.opacity, true, particle.options.opacity.animation.destroy, delta);\r\n    }\r\n}\r\n", "import { OpacityUpdater } from \"./OpacityUpdater.js\";\r\nexport async function loadOpacityUpdater(engine, refresh = true) {\r\n    engine.checkVersion(\"3.9.1\");\r\n    await engine.addParticleUpdater(\"opacity\", container => {\r\n        return Promise.resolve(new OpacityUpdater(container));\r\n    }, refresh);\r\n}\r\n", "import { OutMode, OutModeDirection, getRangeValue } from \"@tsparticles/engine\";\r\nconst minVelocity = 0, boundsMin = 0;\r\nexport function bounceHorizontal(data) {\r\n    if ((data.outMode !== OutMode.bounce && data.outMode !== OutMode.split) ||\r\n        (data.direction !== OutModeDirection.left && data.direction !== OutModeDirection.right)) {\r\n        return;\r\n    }\r\n    if (data.bounds.right < boundsMin && data.direction === OutModeDirection.left) {\r\n        data.particle.position.x = data.size + data.offset.x;\r\n    }\r\n    else if (data.bounds.left > data.canvasSize.width && data.direction === OutModeDirection.right) {\r\n        data.particle.position.x = data.canvasSize.width - data.size - data.offset.x;\r\n    }\r\n    const velocity = data.particle.velocity.x;\r\n    let bounced = false;\r\n    if ((data.direction === OutModeDirection.right &&\r\n        data.bounds.right >= data.canvasSize.width &&\r\n        velocity > minVelocity) ||\r\n        (data.direction === OutModeDirection.left && data.bounds.left <= boundsMin && velocity < minVelocity)) {\r\n        const newVelocity = getRangeValue(data.particle.options.bounce.horizontal.value);\r\n        data.particle.velocity.x *= -newVelocity;\r\n        bounced = true;\r\n    }\r\n    if (!bounced) {\r\n        return;\r\n    }\r\n    const minPos = data.offset.x + data.size;\r\n    if (data.bounds.right >= data.canvasSize.width && data.direction === OutModeDirection.right) {\r\n        data.particle.position.x = data.canvasSize.width - minPos;\r\n    }\r\n    else if (data.bounds.left <= boundsMin && data.direction === OutModeDirection.left) {\r\n        data.particle.position.x = minPos;\r\n    }\r\n    if (data.outMode === OutMode.split) {\r\n        data.particle.destroy();\r\n    }\r\n}\r\nexport function bounceVertical(data) {\r\n    if ((data.outMode !== OutMode.bounce && data.outMode !== OutMode.split) ||\r\n        (data.direction !== OutModeDirection.bottom && data.direction !== OutModeDirection.top)) {\r\n        return;\r\n    }\r\n    if (data.bounds.bottom < boundsMin && data.direction === OutModeDirection.top) {\r\n        data.particle.position.y = data.size + data.offset.y;\r\n    }\r\n    else if (data.bounds.top > data.canvasSize.height && data.direction === OutModeDirection.bottom) {\r\n        data.particle.position.y = data.canvasSize.height - data.size - data.offset.y;\r\n    }\r\n    const velocity = data.particle.velocity.y;\r\n    let bounced = false;\r\n    if ((data.direction === OutModeDirection.bottom &&\r\n        data.bounds.bottom >= data.canvasSize.height &&\r\n        velocity > minVelocity) ||\r\n        (data.direction === OutModeDirection.top && data.bounds.top <= boundsMin && velocity < minVelocity)) {\r\n        const newVelocity = getRangeValue(data.particle.options.bounce.vertical.value);\r\n        data.particle.velocity.y *= -newVelocity;\r\n        bounced = true;\r\n    }\r\n    if (!bounced) {\r\n        return;\r\n    }\r\n    const minPos = data.offset.y + data.size;\r\n    if (data.bounds.bottom >= data.canvasSize.height && data.direction === OutModeDirection.bottom) {\r\n        data.particle.position.y = data.canvasSize.height - minPos;\r\n    }\r\n    else if (data.bounds.top <= boundsMin && data.direction === OutModeDirection.top) {\r\n        data.particle.position.y = minPos;\r\n    }\r\n    if (data.outMode === OutMode.split) {\r\n        data.particle.destroy();\r\n    }\r\n}\r\n", "import { OutMode, calculateBounds, } from \"@tsparticles/engine\";\r\nimport { bounceHorizontal, bounceVertical } from \"./Utils.js\";\r\nexport class BounceOutMode {\r\n    constructor(container) {\r\n        this.container = container;\r\n        this.modes = [\r\n            OutMode.bounce,\r\n            OutMode.split,\r\n        ];\r\n    }\r\n    update(particle, direction, delta, outMode) {\r\n        if (!this.modes.includes(outMode)) {\r\n            return;\r\n        }\r\n        const container = this.container;\r\n        let handled = false;\r\n        for (const plugin of container.plugins.values()) {\r\n            if (plugin.particleBounce !== undefined) {\r\n                handled = plugin.particleBounce(particle, delta, direction);\r\n            }\r\n            if (handled) {\r\n                break;\r\n            }\r\n        }\r\n        if (handled) {\r\n            return;\r\n        }\r\n        const pos = particle.getPosition(), offset = particle.offset, size = particle.getRadius(), bounds = calculateBounds(pos, size), canvasSize = container.canvas.size;\r\n        bounceHorizontal({ particle, outMode, direction, bounds, canvasSize, offset, size });\r\n        bounceVertical({ particle, outMode, direction, bounds, canvasSize, offset, size });\r\n    }\r\n}\r\n", "import { OutMode, ParticleOutType, Vector, getDistances, isPointInside, } from \"@tsparticles/engine\";\r\nconst minVelocity = 0;\r\nexport class DestroyOutMode {\r\n    constructor(container) {\r\n        this.container = container;\r\n        this.modes = [OutMode.destroy];\r\n    }\r\n    update(particle, direction, _delta, outMode) {\r\n        if (!this.modes.includes(outMode)) {\r\n            return;\r\n        }\r\n        const container = this.container;\r\n        switch (particle.outType) {\r\n            case ParticleOutType.normal:\r\n            case ParticleOutType.outside:\r\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\r\n                    return;\r\n                }\r\n                break;\r\n            case ParticleOutType.inside: {\r\n                const { dx, dy } = getDistances(particle.position, particle.moveCenter), { x: vx, y: vy } = particle.velocity;\r\n                if ((vx < minVelocity && dx > particle.moveCenter.radius) ||\r\n                    (vy < minVelocity && dy > particle.moveCenter.radius) ||\r\n                    (vx >= minVelocity && dx < -particle.moveCenter.radius) ||\r\n                    (vy >= minVelocity && dy < -particle.moveCenter.radius)) {\r\n                    return;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        container.particles.remove(particle, particle.group, true);\r\n    }\r\n}\r\n", "import { OutMode, OutModeDirection, Vector, isPointInside, } from \"@tsparticles/engine\";\r\nconst minVelocity = 0;\r\nexport class NoneOutMode {\r\n    constructor(container) {\r\n        this.container = container;\r\n        this.modes = [OutMode.none];\r\n    }\r\n    update(particle, direction, delta, outMode) {\r\n        if (!this.modes.includes(outMode)) {\r\n            return;\r\n        }\r\n        if ((particle.options.move.distance.horizontal &&\r\n            (direction === OutModeDirection.left || direction === OutModeDirection.right)) ??\r\n            (particle.options.move.distance.vertical &&\r\n                (direction === OutModeDirection.top || direction === OutModeDirection.bottom))) {\r\n            return;\r\n        }\r\n        const gravityOptions = particle.options.move.gravity, container = this.container, canvasSize = container.canvas.size, pRadius = particle.getRadius();\r\n        if (!gravityOptions.enable) {\r\n            if ((particle.velocity.y > minVelocity && particle.position.y <= canvasSize.height + pRadius) ||\r\n                (particle.velocity.y < minVelocity && particle.position.y >= -pRadius) ||\r\n                (particle.velocity.x > minVelocity && particle.position.x <= canvasSize.width + pRadius) ||\r\n                (particle.velocity.x < minVelocity && particle.position.x >= -pRadius)) {\r\n                return;\r\n            }\r\n            if (!isPointInside(particle.position, container.canvas.size, Vector.origin, pRadius, direction)) {\r\n                container.particles.remove(particle);\r\n            }\r\n        }\r\n        else {\r\n            const position = particle.position;\r\n            if ((!gravityOptions.inverse &&\r\n                position.y > canvasSize.height + pRadius &&\r\n                direction === OutModeDirection.bottom) ||\r\n                (gravityOptions.inverse && position.y < -pRadius && direction === OutModeDirection.top)) {\r\n                container.particles.remove(particle);\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { OutMode, OutModeDirection, ParticleOutType, Vector, calculateBounds, getDistances, getRandom, isPointInside, randomInRange, } from \"@tsparticles/engine\";\r\nconst minVelocity = 0, minDistance = 0;\r\nexport class OutOutMode {\r\n    constructor(container) {\r\n        this.container = container;\r\n        this.modes = [OutMode.out];\r\n    }\r\n    update(particle, direction, delta, outMode) {\r\n        if (!this.modes.includes(outMode)) {\r\n            return;\r\n        }\r\n        const container = this.container;\r\n        switch (particle.outType) {\r\n            case ParticleOutType.inside: {\r\n                const { x: vx, y: vy } = particle.velocity;\r\n                const circVec = Vector.origin;\r\n                circVec.length = particle.moveCenter.radius;\r\n                circVec.angle = particle.velocity.angle + Math.PI;\r\n                circVec.addTo(Vector.create(particle.moveCenter));\r\n                const { dx, dy } = getDistances(particle.position, circVec);\r\n                if ((vx <= minVelocity && dx >= minDistance) ||\r\n                    (vy <= minVelocity && dy >= minDistance) ||\r\n                    (vx >= minVelocity && dx <= minDistance) ||\r\n                    (vy >= minVelocity && dy <= minDistance)) {\r\n                    return;\r\n                }\r\n                particle.position.x = Math.floor(randomInRange({\r\n                    min: 0,\r\n                    max: container.canvas.size.width,\r\n                }));\r\n                particle.position.y = Math.floor(randomInRange({\r\n                    min: 0,\r\n                    max: container.canvas.size.height,\r\n                }));\r\n                const { dx: newDx, dy: newDy } = getDistances(particle.position, particle.moveCenter);\r\n                particle.direction = Math.atan2(-newDy, -newDx);\r\n                particle.velocity.angle = particle.direction;\r\n                break;\r\n            }\r\n            default: {\r\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\r\n                    return;\r\n                }\r\n                switch (particle.outType) {\r\n                    case ParticleOutType.outside: {\r\n                        particle.position.x =\r\n                            Math.floor(randomInRange({\r\n                                min: -particle.moveCenter.radius,\r\n                                max: particle.moveCenter.radius,\r\n                            })) + particle.moveCenter.x;\r\n                        particle.position.y =\r\n                            Math.floor(randomInRange({\r\n                                min: -particle.moveCenter.radius,\r\n                                max: particle.moveCenter.radius,\r\n                            })) + particle.moveCenter.y;\r\n                        const { dx, dy } = getDistances(particle.position, particle.moveCenter);\r\n                        if (particle.moveCenter.radius) {\r\n                            particle.direction = Math.atan2(dy, dx);\r\n                            particle.velocity.angle = particle.direction;\r\n                        }\r\n                        break;\r\n                    }\r\n                    case ParticleOutType.normal: {\r\n                        const warp = particle.options.move.warp, canvasSize = container.canvas.size, newPos = {\r\n                            bottom: canvasSize.height + particle.getRadius() + particle.offset.y,\r\n                            left: -particle.getRadius() - particle.offset.x,\r\n                            right: canvasSize.width + particle.getRadius() + particle.offset.x,\r\n                            top: -particle.getRadius() - particle.offset.y,\r\n                        }, sizeValue = particle.getRadius(), nextBounds = calculateBounds(particle.position, sizeValue);\r\n                        if (direction === OutModeDirection.right &&\r\n                            nextBounds.left > canvasSize.width + particle.offset.x) {\r\n                            particle.position.x = newPos.left;\r\n                            particle.initialPosition.x = particle.position.x;\r\n                            if (!warp) {\r\n                                particle.position.y = getRandom() * canvasSize.height;\r\n                                particle.initialPosition.y = particle.position.y;\r\n                            }\r\n                        }\r\n                        else if (direction === OutModeDirection.left && nextBounds.right < -particle.offset.x) {\r\n                            particle.position.x = newPos.right;\r\n                            particle.initialPosition.x = particle.position.x;\r\n                            if (!warp) {\r\n                                particle.position.y = getRandom() * canvasSize.height;\r\n                                particle.initialPosition.y = particle.position.y;\r\n                            }\r\n                        }\r\n                        if (direction === OutModeDirection.bottom &&\r\n                            nextBounds.top > canvasSize.height + particle.offset.y) {\r\n                            if (!warp) {\r\n                                particle.position.x = getRandom() * canvasSize.width;\r\n                                particle.initialPosition.x = particle.position.x;\r\n                            }\r\n                            particle.position.y = newPos.top;\r\n                            particle.initialPosition.y = particle.position.y;\r\n                        }\r\n                        else if (direction === OutModeDirection.top && nextBounds.bottom < -particle.offset.y) {\r\n                            if (!warp) {\r\n                                particle.position.x = getRandom() * canvasSize.width;\r\n                                particle.initialPosition.x = particle.position.x;\r\n                            }\r\n                            particle.position.y = newPos.bottom;\r\n                            particle.initialPosition.y = particle.position.y;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { OutMode, OutModeDirection, } from \"@tsparticles/engine\";\r\nimport { BounceOutMode } from \"./BounceOutMode.js\";\r\nimport { DestroyOutMode } from \"./DestroyOutMode.js\";\r\nimport { NoneOutMode } from \"./NoneOutMode.js\";\r\nimport { OutOutMode } from \"./OutOutMode.js\";\r\nconst checkOutMode = (outModes, outMode) => {\r\n    return (outModes.default === outMode ||\r\n        outModes.bottom === outMode ||\r\n        outModes.left === outMode ||\r\n        outModes.right === outMode ||\r\n        outModes.top === outMode);\r\n};\r\nexport class OutOfCanvasUpdater {\r\n    constructor(container) {\r\n        this._addUpdaterIfMissing = (particle, outMode, getUpdater) => {\r\n            const outModes = particle.options.move.outModes;\r\n            if (!this.updaters.has(outMode) && checkOutMode(outModes, outMode)) {\r\n                this.updaters.set(outMode, getUpdater(this.container));\r\n            }\r\n        };\r\n        this._updateOutMode = (particle, delta, outMode, direction) => {\r\n            for (const updater of this.updaters.values()) {\r\n                updater.update(particle, direction, delta, outMode);\r\n            }\r\n        };\r\n        this.container = container;\r\n        this.updaters = new Map();\r\n    }\r\n    init(particle) {\r\n        this._addUpdaterIfMissing(particle, OutMode.bounce, container => new BounceOutMode(container));\r\n        this._addUpdaterIfMissing(particle, OutMode.out, container => new OutOutMode(container));\r\n        this._addUpdaterIfMissing(particle, OutMode.destroy, container => new DestroyOutMode(container));\r\n        this._addUpdaterIfMissing(particle, OutMode.none, container => new NoneOutMode(container));\r\n    }\r\n    isEnabled(particle) {\r\n        return !particle.destroyed && !particle.spawning;\r\n    }\r\n    update(particle, delta) {\r\n        const outModes = particle.options.move.outModes;\r\n        this._updateOutMode(particle, delta, outModes.bottom ?? outModes.default, OutModeDirection.bottom);\r\n        this._updateOutMode(particle, delta, outModes.left ?? outModes.default, OutModeDirection.left);\r\n        this._updateOutMode(particle, delta, outModes.right ?? outModes.default, OutModeDirection.right);\r\n        this._updateOutMode(particle, delta, outModes.top ?? outModes.default, OutModeDirection.top);\r\n    }\r\n}\r\n", "import { OutOfCanvasUpdater } from \"./OutOfCanvasUpdater.js\";\r\nexport async function loadOutModesUpdater(engine, refresh = true) {\r\n    engine.checkVersion(\"3.9.1\");\r\n    await engine.addParticleUpdater(\"outModes\", container => {\r\n        return Promise.resolve(new OutOfCanvasUpdater(container));\r\n    }, refresh);\r\n}\r\n", "import { getRangeValue, parseAlpha, } from \"@tsparticles/engine\";\r\nvar RgbIndexes;\r\n(function (RgbIndexes) {\r\n    RgbIndexes[RgbIndexes[\"r\"] = 1] = \"r\";\r\n    RgbIndexes[RgbIndexes[\"g\"] = 2] = \"g\";\r\n    RgbIndexes[RgbIndexes[\"b\"] = 3] = \"b\";\r\n    RgbIndexes[RgbIndexes[\"a\"] = 5] = \"a\";\r\n})(RgbIndexes || (RgbIndexes = {}));\r\nexport class RgbColorManager {\r\n    constructor() {\r\n        this.key = \"rgb\";\r\n        this.stringPrefix = \"rgb\";\r\n    }\r\n    handleColor(color) {\r\n        const colorValue = color.value, rgbColor = colorValue.rgb ?? color.value;\r\n        if (rgbColor.r !== undefined) {\r\n            return rgbColor;\r\n        }\r\n    }\r\n    handleRangeColor(color) {\r\n        const colorValue = color.value, rgbColor = colorValue.rgb ?? color.value;\r\n        if (rgbColor.r !== undefined) {\r\n            return {\r\n                r: getRangeValue(rgbColor.r),\r\n                g: getRangeValue(rgbColor.g),\r\n                b: getRangeValue(rgbColor.b),\r\n            };\r\n        }\r\n    }\r\n    parseString(input) {\r\n        if (!input.startsWith(this.stringPrefix)) {\r\n            return;\r\n        }\r\n        const regex = /rgba?\\(\\s*(\\d{1,3})\\s*[\\s,]\\s*(\\d{1,3})\\s*[\\s,]\\s*(\\d{1,3})\\s*([\\s,]\\s*(0|1|0?\\.\\d+|(\\d{1,3})%)\\s*)?\\)/i, result = regex.exec(input), radix = 10, minLength = 4, defaultAlpha = 1;\r\n        return result\r\n            ? {\r\n                a: result.length > minLength ? parseAlpha(result[RgbIndexes.a]) : defaultAlpha,\r\n                b: parseInt(result[RgbIndexes.b], radix),\r\n                g: parseInt(result[RgbIndexes.g], radix),\r\n                r: parseInt(result[RgbIndexes.r], radix),\r\n            }\r\n            : undefined;\r\n    }\r\n}\r\n", "import { RgbColorManager } from \"./RgbColorManager.js\";\r\nexport async function loadRgbColorPlugin(engine, refresh = true) {\r\n    engine.checkVersion(\"3.9.1\");\r\n    await engine.addColorManager(new RgbColorManager(), refresh);\r\n}\r\n", "import { getRandom, percentDenominator, updateAnimation, } from \"@tsparticles/engine\";\r\nconst minLoops = 0;\r\nexport class SizeUpdater {\r\n    init(particle) {\r\n        const container = particle.container, sizeOptions = particle.options.size, sizeAnimation = sizeOptions.animation;\r\n        if (sizeAnimation.enable) {\r\n            particle.size.velocity =\r\n                ((particle.retina.sizeAnimationSpeed ?? container.retina.sizeAnimationSpeed) / percentDenominator) *\r\n                    container.retina.reduceFactor;\r\n            if (!sizeAnimation.sync) {\r\n                particle.size.velocity *= getRandom();\r\n            }\r\n        }\r\n    }\r\n    isEnabled(particle) {\r\n        return (!particle.destroyed &&\r\n            !particle.spawning &&\r\n            particle.size.enable &&\r\n            ((particle.size.maxLoops ?? minLoops) <= minLoops ||\r\n                ((particle.size.maxLoops ?? minLoops) > minLoops &&\r\n                    (particle.size.loops ?? minLoops) < (particle.size.maxLoops ?? minLoops))));\r\n    }\r\n    reset(particle) {\r\n        particle.size.loops = minLoops;\r\n    }\r\n    update(particle, delta) {\r\n        if (!this.isEnabled(particle)) {\r\n            return;\r\n        }\r\n        updateAnimation(particle, particle.size, true, particle.options.size.animation.destroy, delta);\r\n    }\r\n}\r\n", "import { SizeUpdater } from \"./SizeUpdater.js\";\r\nexport async function loadSizeUpdater(engine, refresh = true) {\r\n    engine.checkVersion(\"3.9.1\");\r\n    await engine.addParticleUpdater(\"size\", () => {\r\n        return Promise.resolve(new SizeUpdater());\r\n    }, refresh);\r\n}\r\n", "import { loadBaseMover } from \"@tsparticles/move-base\";\r\nimport { loadCircleShape } from \"@tsparticles/shape-circle\";\r\nimport { loadColorUpdater } from \"@tsparticles/updater-color\";\r\nimport { loadHexColorPlugin } from \"@tsparticles/plugin-hex-color\";\r\nimport { loadHslColorPlugin } from \"@tsparticles/plugin-hsl-color\";\r\nimport { loadOpacityUpdater } from \"@tsparticles/updater-opacity\";\r\nimport { loadOutModesUpdater } from \"@tsparticles/updater-out-modes\";\r\nimport { loadRgbColorPlugin } from \"@tsparticles/plugin-rgb-color\";\r\nimport { loadSizeUpdater } from \"@tsparticles/updater-size\";\r\nexport async function loadBasic(engine, refresh = true) {\r\n    engine.checkVersion(\"3.9.1\");\r\n    await loadHexColorPlugin(engine, false);\r\n    await loadHslColorPlugin(engine, false);\r\n    await loadRgbColorPlugin(engine, false);\r\n    await loadBaseMover(engine, false);\r\n    await loadCircleShape(engine, false);\r\n    await loadColorUpdater(engine, false);\r\n    await loadOpacityUpdater(engine, false);\r\n    await loadOutModesUpdater(engine, false);\r\n    await loadSizeUpdater(engine, false);\r\n    await engine.refresh(refresh);\r\n}\r\n", "import { deepExtend, executeOnSingleOrMultiple, isNull, setRangeValue, } from \"@tsparticles/engine\";\r\nexport class Push {\r\n    constructor() {\r\n        this.default = true;\r\n        this.groups = [];\r\n        this.quantity = 4;\r\n    }\r\n    load(data) {\r\n        if (isNull(data)) {\r\n            return;\r\n        }\r\n        if (data.default !== undefined) {\r\n            this.default = data.default;\r\n        }\r\n        if (data.groups !== undefined) {\r\n            this.groups = data.groups.map(t => t);\r\n        }\r\n        if (!this.groups.length) {\r\n            this.default = true;\r\n        }\r\n        const quantity = data.quantity;\r\n        if (quantity !== undefined) {\r\n            this.quantity = setRangeValue(quantity);\r\n        }\r\n        this.particles = executeOnSingleOrMultiple(data.particles, particles => {\r\n            return deepExtend({}, particles);\r\n        });\r\n    }\r\n}\r\n", "import { ExternalInteractorBase, deepExtend, getRangeValue, itemFromArray, itemFromSingleOrMultiple, } from \"@tsparticles/engine\";\r\nimport { Push } from \"./Options/Classes/Push.js\";\r\nconst pushMode = \"push\", minQuantity = 0;\r\nexport class Pusher extends ExternalInteractorBase {\r\n    constructor(container) {\r\n        super(container);\r\n        this.handleClickMode = (mode) => {\r\n            if (mode !== pushMode) {\r\n                return;\r\n            }\r\n            const container = this.container, options = container.actualOptions, pushOptions = options.interactivity.modes.push;\r\n            if (!pushOptions) {\r\n                return;\r\n            }\r\n            const quantity = getRangeValue(pushOptions.quantity);\r\n            if (quantity <= minQuantity) {\r\n                return;\r\n            }\r\n            const group = itemFromArray([undefined, ...pushOptions.groups]), groupOptions = group !== undefined ? container.actualOptions.particles.groups[group] : undefined, particlesOptions = itemFromSingleOrMultiple(pushOptions.particles), overrideOptions = deepExtend(groupOptions, particlesOptions);\r\n            void container.particles.push(quantity, container.interactivity.mouse, overrideOptions, group);\r\n        };\r\n    }\r\n    clear() {\r\n    }\r\n    init() {\r\n    }\r\n    interact() {\r\n    }\r\n    isEnabled() {\r\n        return true;\r\n    }\r\n    loadModeOptions(options, ...sources) {\r\n        if (!options.push) {\r\n            options.push = new Push();\r\n        }\r\n        for (const source of sources) {\r\n            options.push.load(source?.push);\r\n        }\r\n    }\r\n    reset() {\r\n    }\r\n}\r\n", "import { Pusher } from \"./Pusher.js\";\r\nexport async function loadExternalPushInteraction(engine, refresh = true) {\r\n    engine.checkVersion(\"3.9.1\");\r\n    await engine.addInteractor(\"externalPush\", container => {\r\n        return Promise.resolve(new Pusher(container));\r\n    }, refresh);\r\n}\r\nexport * from \"./Options/Classes/Push.js\";\r\nexport * from \"./Options/Interfaces/IPush.js\";\r\n", "export const options = {\r\n    fpsLimit: 40,\r\n    particles: {\r\n        number: {\r\n            value: 200,\r\n            density: {\r\n                enable: true,\r\n            },\r\n        },\r\n        color: {\r\n            value: [\"#fdcf58\", \"#757676\", \"#f27d0c\", \"#800909\", \"#f07f13\"],\r\n        },\r\n        opacity: {\r\n            value: { min: 0.1, max: 0.5 },\r\n        },\r\n        size: {\r\n            value: { min: 1, max: 3 },\r\n        },\r\n        move: {\r\n            enable: true,\r\n            speed: 6,\r\n            random: false,\r\n        },\r\n    },\r\n    interactivity: {\r\n        detectsOn: \"window\",\r\n        events: {\r\n            onClick: {\r\n                enable: true,\r\n                mode: \"push\",\r\n            },\r\n        },\r\n    },\r\n    background: {\r\n        image: \"radial-gradient(#4a0000, #000)\",\r\n    },\r\n};\r\n", "import { loadBasic } from \"@tsparticles/basic\";\r\nimport { loadExternalPushInteraction } from \"@tsparticles/interaction-external-push\";\r\nimport { options } from \"./options.js\";\r\nexport async function loadFirePreset(engine, refresh = true) {\r\n    await loadBasic(engine, false);\r\n    await loadExternalPushInteraction(engine, false);\r\n    await engine.addPreset(\"fire\", options, false);\r\n    await engine.refresh(refresh);\r\n}\r\n"],
  "mappings": "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",
  "names": ["options", "spinFactor", "options", "double", "doublePI", "minAngle", "RgbIndexes", "HslIndexes", "defaultAlpha", "minVelocity", "minVelocity", "minVelocity", "minVelocity", "RgbIndexes", "defaultAlpha", "container", "options"]
}
